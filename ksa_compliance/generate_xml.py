import os
import sys

import OpenSSL

import frappe
import json


@frappe.whitelist(allow_guest=True)
def generate_xml(input_data: dict = None):
    """
    For postman testing purpose
    """
    data = input_data or frappe.request.data
    if not isinstance(data, dict):
        data = json.loads(data)

    invoice_type = data.get("invoice_type")
    template = "simplified_e_invoice.xml" if invoice_type.lower() == "simplified" else "standard_e_invoice.xml"

    # render XML Template
    invoice_xml = frappe.render_template(
        f"ksa_compliance/templates/{template}",
        context={"invoice": data.get("invoice"), "seller": data.get("seller"), "buyer": data.get("buyer"),
                 "business_settings": data.get("business_settings")},
        is_path=True
    )
    invoice_xml = invoice_xml.replace("&", "&amp;")
    invoice_xml = invoice_xml.replace("\n", "")

    return invoice_xml


def generate_xml_file(data, invoice_type: str = "Simplified"):
    """
    For Generating cycle
    """

    template = "simplified_e_invoice.xml" if invoice_type.lower() == "simplified" else "standard_e_invoice.xml"

    # render XML Template
    invoice_xml = frappe.render_template(
        f"ksa_compliance/templates/{template}",
        context={
            "invoice": data.get("invoice"),
            "seller_details": data.get("seller_details"),
            "buyer_details": data.get("buyer_details"),
            "business_settings": data.get("business_settings")},
        is_path=True
    )
    invoice_xml = invoice_xml.replace("&", "&amp;")
    invoice_xml = invoice_xml.replace("\n", "")
    xml_filename = generate_einvoice_xml_fielname(data['business_settings'], data["invoice"])
    file = frappe.get_doc(
        {
            "doctype": "File",
            "file_name": xml_filename,
            "attached_to_doctype": "Sales Invoice",
            "attached_to_name": data["invoice"]["id"],
            "content": invoice_xml,
        }
    )
    file.insert()
    # generate_sign(data["invoice"])


def generate_einvoice_xml_fielname(business_settings, invoice):
    vat_registration_number = business_settings["company_id"]
    invoice_date = invoice["issue_date"].replace("-", "")
    invoice_time = invoice["issue_time"].replace(":", "")
    invoice_number = invoice["id"]
    file_name = vat_registration_number + "_" + invoice_date + "T" + invoice_time + "_" + invoice_number
    progressive_name = frappe.model.naming.make_autoname(file_name)
    progressive_name = progressive_name[:len(file_name)]
    return progressive_name + ".xml"


def generate_sign(doc):
    import chilkat2
    cwd = os.getcwd()

    attachments = frappe.get_all(
        "File",
        fields=("name", "file_name", "attached_to_name", "file_url"),
        filters={"attached_to_name": ("in", doc["id"]), "attached_to_doctype": "Sales Invoice"},
    )

    for attachment in attachments:
        if (
                attachment.file_name
                and attachment.file_name.endswith(".xml")

        ):
            xml_filename = attachment.file_name
            file_url = attachment.file_url

    cwd = os.getcwd()
    signedxmlll = "Signed" + xml_filename
    site = (frappe.local.site)
    # xml_file = cwd+'/mum128.erpgulf.com/public'+file_url
    xml_file = cwd + '/' + site + '/public' + file_url

    sbXml = chilkat2.StringBuilder()
    success = sbXml.LoadFile(xml_file, "utf-8")

    if (success == False):
        print("Failed to load XML file to be signed.")
        sys.exit()

    gen = chilkat2.XmlDSigGen()

    gen.SigLocation = "Invoice|ext:UBLExtensions|ext:UBLExtension|ext:ExtensionContent|sig:UBLDocumentSignatures|sac:SignatureInformation"

    gen.SigLocationMod = 0
    gen.SigId = "signature"
    gen.SigNamespacePrefix = "ds"
    gen.SigNamespaceUri = "http://www.w3.org/2000/09/xmldsig#"
    gen.SignedInfoCanonAlg = "C14N_11"
    gen.SignedInfoDigestMethod = "sha256"

    # Create an Object to be added to the Signature.
    object1 = chilkat2.Xml()
    object1.Tag = "xades:QualifyingProperties"
    object1.AddAttribute("xmlns:xades", "http://uri.etsi.org/01903/v1.3.2#")
    object1.AddAttribute("Target", "signature")
    object1.UpdateAttrAt("xades:SignedProperties", True, "Id", "xadesSignedProperties")
    object1.UpdateChildContent("xades:SignedProperties|xades:SignedSignatureProperties|xades:SigningTime",
                               "TO BE GENERATED BY CHILKAT")
    object1.UpdateAttrAt(
        "xades:SignedProperties|xades:SignedSignatureProperties|xades:SigningCertificate|xades:Cert|xades:CertDigest|ds:DigestMethod",
        True, "Algorithm", "http://www.w3.org/2001/04/xmlenc#sha256")
    object1.UpdateChildContent(
        "xades:SignedProperties|xades:SignedSignatureProperties|xades:SigningCertificate|xades:Cert|xades:CertDigest|ds:DigestValue",
        "TO BE GENERATED BY CHILKAT")
    object1.UpdateChildContent(
        "xades:SignedProperties|xades:SignedSignatureProperties|xades:SigningCertificate|xades:Cert|xades:IssuerSerial|ds:X509IssuerName",
        "TO BE GENERATED BY CHILKAT")
    object1.UpdateChildContent(
        "xades:SignedProperties|xades:SignedSignatureProperties|xades:SigningCertificate|xades:Cert|xades:IssuerSerial|ds:X509SerialNumber",
        "TO BE GENERATED BY CHILKAT")

    gen.AddObject("", object1.GetXml(), "", "")

    xml1 = chilkat2.Xml()
    xml1.Tag = "ds:Transforms"
    xml1.UpdateAttrAt("ds:Transform", True, "Algorithm", "http://www.w3.org/TR/1999/REC-xpath-19991116")
    xml1.UpdateChildContent("ds:Transform|ds:XPath", "not(//ancestor-or-self::ext:UBLExtensions)")
    xml1.UpdateAttrAt("ds:Transform[1]", True, "Algorithm", "http://www.w3.org/TR/1999/REC-xpath-19991116")
    xml1.UpdateChildContent("ds:Transform[1]|ds:XPath", "not(//ancestor-or-self::cac:Signature)")
    xml1.UpdateAttrAt("ds:Transform[2]", True, "Algorithm", "http://www.w3.org/TR/1999/REC-xpath-19991116")
    xml1.UpdateChildContent("ds:Transform[2]|ds:XPath",
                            "not(//ancestor-or-self::cac:AdditionalDocumentReference[cbc:ID='QR'])")
    xml1.UpdateAttrAt("ds:Transform[3]", True, "Algorithm", "http://www.w3.org/2006/12/xml-c14n11")

    gen.AddSameDocRef2("", "sha256", xml1, "")

    gen.SetRefIdAttr("", "invoiceSignedData")

    gen.AddObjectRef("xadesSignedProperties", "sha256", "", "", "http://www.w3.org/2000/09/xmldsig#SignatureProperties")
    cwd = os.getcwd()

    cer = cwd + '/' + site + "/public/files/testcertt.cer"
    pkey = cwd + '/' + site + "/public/files/testpkeyy.pem"
    pfx = cwd + '/' + site + "/public/files/testpfxx.pfx"
    key = OpenSSL.crypto.PKey()
    key.generate_key(OpenSSL.crypto.TYPE_RSA, 1024)
    cert = OpenSSL.crypto.X509()
    cert.set_serial_number(0)
    cert.get_subject().CN = "me"
    cert.set_issuer(cert.get_subject())
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(10 * 365 * 24 * 60 * 60)
    cert.set_pubkey(key)
    cert.sign(key, 'md5')
    open(cer, 'wb').write(
        OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert))
    open(pkey, 'wb').write(
        OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key))
    p12 = OpenSSL.crypto.PKCS12()
    p12.set_privatekey(key)
    p12.set_certificate(cert)
    open(pfx, 'wb').write(p12.export())
    # Provide a certificate + private key. (PFX password is test123)
    certFromPfx = chilkat2.Cert()

    success = certFromPfx.LoadPfxFile(pfx, "")

    if (success != True):
        print(certFromPfx.LastErrorText)
        sys.exit()

    # Alternatively, if your certificate and private key are in separate PEM files, do this:
    certt = chilkat2.Cert()
    success = certt.LoadFromFile(cer)

    if (success != True):
        return (cert.LastErrorText)
        sys.exit()

    # return (cert.SubjectCN)

    # Load the private key.
    privKey = chilkat2.PrivateKey()
    success = privKey.LoadPemFile(pkey)

    if (success != True):
        print(privKey.LastErrorText)
        sys.exit()

    print("Key Type: " + privKey.KeyType)

    # Associate the private key with the certificate.
    success = certt.SetPrivateKey(privKey)

    if (success != True):
        print(certt.LastErrorText)
        sys.exit()

    # The certificate passed to SetX509Cert must have an associated private key.
    # If the cert was loaded from a PFX, then it should automatically has an associated private key.
    # If the cert was loaded from PEM, then the private key was explicitly associated as shown above.
    success = gen.SetX509Cert(certt, True)

    if (success != True):
        print(gen.LastErrorText)
        sys.exit()

    gen.KeyInfoType = "X509Data"

    gen.X509Type = "Certificate"

    # Starting in Chilkat v9.5.0.92, add the "ZATCA" behavior to produce the format required by ZATCA.
    gen.Behaviors = "IndentedSignature,TransformSignatureXPath,ZATCA"

    # Sign the XML...
    success = gen.CreateXmlDSigSb(sbXml)

    if (success != True):
        print(gen.LastErrorText)
        sys.exit()

    # Save the signed XML to a file.
    # success = sbXml.WriteFile(cwd+'/mum128.erpgulf.com'+"/public/files/"+ signedxmlll,"utf-8",False)
    success = sbXml.WriteFile(cwd + '/' + site + "/public/files/" + signedxmlll, "utf-8", False)

    print(sbXml.GetAsString())

    signedd_xml = sbXml.GetAsString()

    # Verify the signatures produced
    verifier = chilkat2.XmlDSig()
    success = verifier.LoadSignatureSb(sbXml)
    if (success != True):
        print(verifier.LastErrorText)
        sys.exit()

    # to validate signed XML according to ZATCA needs.

    verifier.UncommonOptions = "ZATCA"

    numSigs = verifier.NumSignatures
    verifyIdx = 0
    while verifyIdx < numSigs:
        verifier.Selector = verifyIdx
        verified = verifier.VerifySignature(True)
        if (verified != True):
            print(verifier.LastErrorText)
            sys.exit()

        verifyIdx = verifyIdx + 1

    print("All signatures were successfully verified.")
    signed_file = frappe.get_doc(
        {
            "doctype": "File",
            "file_name": signedxmlll,
            "attached_to_doctype": "Sales Invoice",
            "attached_to_name": doc["id"],

            "content": signedd_xml,
        }
    )
    signed_file.save()

    return signed_file
